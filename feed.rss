<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Henrik Forsberg</title><description>A description of Forsbergdevsite</description><link>https://your-website-url.com</link><language>en</language><lastBuildDate>Sat, 12 Aug 2023 16:24:38 +0200</lastBuildDate><pubDate>Sat, 12 Aug 2023 16:24:38 +0200</pubDate><ttl>250</ttl><atom:link href="https://your-website-url.com/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://your-website-url.com/posts/Dependency%20Inversion%20Principle</guid><title>Dependency Inversion Principle in Swift</title><description>High level modules should not depend upon low level modules. Both should depend upon abstractions.  Abstractions should not depend upon details. Details should depend upon abstractions. High level modules should not depend upon low level modules. Both should depend upon abstractions.  Abstractions should not depend upon details. Details should depend upon abstractions. High level modules should not depend upon low level modules. Both should depend upon abstractions.  Abstractions should not depend upon details. Details should depend upon abstractions. High level modules should not depend upon low level modules. Both should depend upon abstractions.  Abstractions should not depend upon details. Details should depend upon abstractions. High level modules should not depend upon low level modules. Both should depend upon abstractions.  Abstractions should not depend upon details. Details should depend upon abstractions.</description><link>https://your-website-url.com/posts/Dependency%20Inversion%20Principle</link><pubDate>Fri, 1 Dec 2023 01:00:00 +0100</pubDate><content:encoded><![CDATA[<h1>Dependency Inversion Principle in Swift</h1><p>test</p>]]></content:encoded></item><item><guid isPermaLink="true">https://your-website-url.com/posts/Interface%20Segregation%20Principle</guid><title>Interface Segregation Principle in Swift</title><description>Clients should not be forced to depend upon interfaces that they do not use. Clients should not be forced to depend upon interfaces that they do not use. Clients should not be forced to depend upon interfaces that they do not use. Clients should not be forced to depend upon interfaces that they do not use. Clients should not be forced to depend upon interfaces that they do not use.</description><link>https://your-website-url.com/posts/Interface%20Segregation%20Principle</link><pubDate>Wed, 1 Nov 2023 01:00:00 +0100</pubDate><content:encoded><![CDATA[<h1>Interface Segregation Principle in Swift</h1>]]></content:encoded></item><item><guid isPermaLink="true">https://your-website-url.com/posts/Liskov%20Substitution%20Principle</guid><title>Liskov Substitution Principle in Swift</title><description>Programs that references an object from a base class must be able to use an object of a derived class without behavior differences and without knowing about its existence. Programs that references an object from a base class must be able to use an object of a derived class without behavior differences and without knowing about its existence. Programs that references an object from a base class must be able to use an object of a derived class without behavior differences and without knowing about its existence. Programs that references an object from a base class must be able to use an object of a derived class without behavior differences and without knowing about its existence. Programs that references an object from a base class must be able to use an object of a derived class without behavior differences and without knowing about its existence.</description><link>https://your-website-url.com/posts/Liskov%20Substitution%20Principle</link><pubDate>Sun, 1 Oct 2023 01:00:00 +0200</pubDate><content:encoded><![CDATA[<h1>Liskov Substitution Principle in Swift</h1>]]></content:encoded></item><item><guid isPermaLink="true">https://your-website-url.com/posts/Open-Closed%20Principle%20in%20Swift</guid><title>Open-Closed Principle in Swift</title><description>Software Entities (classes, modules, functions, etc) should be open for extension, but closed for modification. Software Entities (classes, modules, functions, etc) should be open for extension, but closed for modification. Software Entities (classes, modules, functions, etc) should be open for extension, but closed for modification. Software Entities (classes, modules, functions, etc) should be open for extension, but closed for modification. Software Entities (classes, modules, functions, etc) should be open for extension, but closed for modification.</description><link>https://your-website-url.com/posts/Open-Closed%20Principle%20in%20Swift</link><pubDate>Fri, 1 Sep 2023 01:00:00 +0200</pubDate><content:encoded><![CDATA[<h1>Open-Closed Principle in Swift</h1><p>Software Entities (classes, modules, functions, etc) should be open for extension, but closed for modification. Software Entities (classes, modules, functions, etc) should be open for extension, but closed for modification. Software Entities (classes, modules, functions, etc) should be open for extension, but closed for modification. Software Entities (classes, modules, functions, etc) should be open for extension, but closed for modification. Software Entities (classes, modules, functions, etc) should be open for extension, but closed for modification.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://your-website-url.com/posts/Single%20Responsibility%20Principle%20in%20Swift</guid><title>SOLID Principles: Single Responsibility Principle in Swift</title><description>As a project's codebase matures and becomes more complex, it's very easy to lose control over maintainability and scalability of the app. It becomes increasingly important to follow best practices and use well-established design patterns and architectures to ensure a robust application. The SOLID principles are a very common set of principles we can use for this purpose. In this post, we take a look at the "S" in SOLID used for avoiding too many responsibilities within a class or function; the Single Responsibility Principle.</description><link>https://your-website-url.com/posts/Single%20Responsibility%20Principle%20in%20Swift</link><pubDate>Fri, 18 Aug 2023 01:00:00 +0200</pubDate><content:encoded><![CDATA[<h1>SOLID Principles: Single Responsibility Principle in Swift</h1><p>As a project's codebase matures and becomes more complex, it's very easy to lose control over maintainability and scalability of the app. It becomes increasingly important to follow best practices and use well-established design patterns and architectures to ensure a robust application. The SOLID principles are a very common set of principles we can use for this purpose. In this post, we take a look at the "S" in SOLID used for avoiding too many responsibilities within a class or function; the Single Responsibility Principle.</p><h2>What is the Single Responsibility Principle?</h2><p>First of all, we need to understand what the SRP is and why we need it. What problem does it solve?</p><p>Robert C. Martin (the famous Uncle Bob) defines the principle like this:</p><blockquote><p>"A class should have one, and only one, reason to change."</p></blockquote><p>Basically the idea is that every module, class or function should only have one responsibility or job within an application. This makes it easier to understand, modify, maintain and reuse.</p><p>Sounds good. But what does it actually mean? And how do we spot it in code?</p><h2>Identifying the Problem: Multiple Responsibilities in One</h2><p>I find it easier to understand an issue by looking at an example, so let's see some code. Imagine a scenario where we have a class or function that juggles multiple responsibilities. Let's say we have a <code>Spaceship</code> class:</p><pre><code><span class="keyword">class</span> Spaceship {
    <span class="keyword">func</span> travel(destination: <span class="type">String</span>) {
        <span class="comment">// Travel to the specified destination</span>
    }
    
    <span class="keyword">func</span> formLandingParty() {
        <span class="comment">// Form a landing party using the spaceship's crew</span>
    }
}
</code></pre><p>In this simple example we see that the <code>Spaceship</code> class handles logic for both travel and forming landing parties. It has multiple responsibilities and thus it is violating the Single Responsibility Principle. Even though at first glance this might seem fine and quite convenient, as changes pile up over time (as we all know they do) the class could easily become a tangled mess. Adding a new feature might unintentionally break existing functionality and debugging becomes a daunting task. So how do we prevent this from happening?</p><h2>Applying the Solution: SRP</h2><p>The Single Responsibility Principle comes to the rescue by advocating for a clear separation of concerns. Instead of having a single class do everything, we break down the responsibilities into distinct, standalone entities. Taking the previous example, we create separate classes for dealing with traveling and managing crew members. Consider the following:</p><pre><code><span class="keyword">class</span> Spaceship {
    <span class="keyword">func</span> travel(destination: <span class="type">String</span>) {
        <span class="comment">// Travel to the specified destination</span>
    }
}

<span class="keyword">class</span> CrewManager {
    <span class="keyword">func</span> formLandingParty(spaceship: <span class="type">Spaceship</span>) {
        <span class="comment">// Form a landing party using the spaceship's crew</span>
    }
}
</code></pre><p>By applying SRP, each class now has a single focus, making code easier to understand, maintain, and extend. Changes related to travel won't affect crew management, and vice versa. This separation results in a more modular codebase, reducing the chances of introducing unintended side effects. Also, it will be easier to test these classes in isolation.</p><p>The benefits extend beyond initial development—maintenance and debugging become smoother processes, and the overall quality of the codebase improves.</p><p>In conclusion, the Single Responsibility Principle is a powerful tool that promotes cleaner, more maintainable code. By adhering to SRP, developers can address the challenges of growing codebases head-on, fostering a more efficient and enjoyable development experience.</p><p>Identifying SRP violations</p><h2>How to find these violations?</h2><p>Enforcing SRP</p><p>Mention: Coupling Tight coupling = Changing one class results in having to change a lot of other classes to get the program working again Cohesion Low Cohesion = The class contains fields and methods/functions that are unrelated to each other in any meaningful way. A good way to spot this is if methods in a class don't reuse the same fields. Each method is using different fields from the class.</p><p>So a class adhering to SRP should preferrably have loose coupling and high cohesion.</p><p>Swiss army knife is a great example of SRP violation. Trying to do too much and end up doing nothing well.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://your-website-url.com/about/aboutme</guid><title>About Me</title><description></description><link>https://your-website-url.com/about/aboutme</link><pubDate>Fri, 28 Jul 2023 20:10:06 +0200</pubDate><content:encoded><![CDATA[<h1>About Me</h1><img src="https://your-website-url.com/images/profile-pic.jpg" alt="" class="profile-image" /><p>Hey there!</p><p>I'm Henrik, an iOS developer with a passion for crafting immersive app experiences. Since 2014, I've been deeply involved in iOS development, transitioning from Objective-C to Swift.</p><p>Building iOS apps isn't just a job for me; it's a calling that fuels my creativity. Through this website, I share my experiences and insights with the iOS community, offering articles and tutorials to help developers of all levels grow their skills. Let's connect and embark on this exciting journey together!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://your-website-url.com/posts/Test-Driven%20Bug%20Fixing</guid><title>Test-Driven Bug Fixing</title><description>Boost your confidence and ensure solid fixes by applying the Red, Green, Refactor process.</description><link>https://your-website-url.com/posts/Test-Driven%20Bug%20Fixing</link><pubDate>Sun, 19 Mar 2023 13:29:00 +0100</pubDate><content:encoded><![CDATA[<h1>Test-Driven Bug Fixing</h1><h2>Introduction</h2><p>As a software developer, it's not uncommon to encounter bugs in code. Fixing bugs can be a tedious and time-consuming process, but there are ways to make it more efficient. One such way is through test-driven bug fixing, which involves using the red, green, refactor process.</p><h2>The Red, Green, Refactor Process</h2><p>The red, green, refactor process is a way of writing code that ensures it is thoroughly tested before it is committed to the codebase. It involves three steps:</p><h3>Red 🔴</h3><p>The first step is to write a failing test. This is the "red" step because the test should fail at this stage. The test should be specific to the bug that needs to be fixed and should only test for that particular behavior.</p><h3>Green 🟢</h3><p>The second step is to write the minimum amount of code to make the test pass. This is the "green" step because the test should now pass. The code written at this stage should only address the specific bug being fixed and should not add any additional functionality.</p><h3>Refactor 🔄</h3><p>The final step is to refactor the code to make it easier to read, maintain, and extend. This is the "refactor" step because the code is being cleaned up and improved without changing its behavior. Refactoring at this stage ensures that the codebase remains clean and easy to work with.</p><h4>Header 4</h4><p>The final step is to refactor the code to make it easier to read, maintain, and extend. This is the "refactor" step because the code is being cleaned up and improved without changing its behavior. Refactoring at this stage ensures that the codebase remains clean and easy to work with.</p><h2>Benefits of Test Driven Bug Fixing</h2><p>Test-driven bug fixing has several benefits. First, it ensures that the bug is fixed thoroughly and does not introduce any additional issues into the codebase. Second, it makes the codebase more stable and reliable by ensuring that all changes are properly tested. Finally, it can save time in the long run by catching issues early in the development process.</p><h2>Using Test Driven Bug Fixing with Legacy Code</h2><p>While implementing test-driven bug fixing may be more challenging with legacy code, it can still be done. By writing tests that cover the most critical parts of the code, developers can gradually build up test coverage over time. As more tests are written, the codebase becomes more reliable and easier to work with. It's important to note that the red, green, refactor process may need to be adapted to fit the specific needs of the legacy codebase.</p><h2>Conclusion</h2><p>Test-driven bug fixing is a powerful technique for ensuring that bugs are thoroughly tested and fixed without introducing additional issues. By following the red, green, refactor process, developers can ensure that their code is clean, stable, and reliable. So next time you encounter a bug, consider using test-driven bug fixing to ensure a more efficient and effective fix, even if you are working with legacy code.</p><ol><li>Test-driven bug fixing is a powerful technique for ensuring that bugs are thoroughly tested and fixed without introducing additional issues. By following the red, green, refactor process, developers can ensure that their code is clean, stable, and reliable. So next time you encounter a bug, consider using test-driven bug fixing to ensure a more efficient and effective fix, even if you are working with legacy code.<ul><li>bla bla bla</li><li>hya hya hya hya</li><li>ho ho ho</li></ul></li></ol><ol start="2"><li>Test-driven bug fixing is a powerful technique for ensuring that bugs are thoroughly tested and fixed without introducing additional issues. By following the red, green, refactor process, developers can ensure that their code is clean, stable, and reliable. So next time you encounter a bug, consider using test-driven bug fixing to ensure a more efficient and effective fix, even if you are working with legacy code.</li></ol><p>Test-driven bug fixing is a powerful technique for ensuring that bugs are thoroughly tested and fixed without introducing additional issues. By following the red, green, refactor process, developers <a href="https://www.google.se">developers</a> developers can ensure that their code is clean, stable, and reliable. So next time you encounter a bug, consider using test-driven bug fixing to ensure a more efficient and effective fix, even if you are working with legacy code.</p><blockquote><p>Test-driven bug fixing is a powerful technique for ensuring that bugs are thoroughly tested and fixed without introducing additional issues. By following the red, green, refactor process, developers can ensure that their code is clean, stable, and reliable. So next time you encounter a bug, consider using test-driven bug fixing to ensure a more efficient and effective fix, even if you are working with legacy code.</p></blockquote><p>Test-driven bug fixing is a <strong>powerful</strong> technique for ensuring that bugs are thoroughly tested and fixed without introducing additional issues. By following the red, green, refactor process, developers <code>class Progress: NSObject</code> can ensure that their <code>code</code> is clean, stable, and reliable. So next time you encounter a bug, consider using <em>test-driven</em> bug fixing to ensure a more efficient and effective fix, even if you are working with legacy code.</p><hr><p>Test-driven bug fixing is a <strong>powerful</strong> technique for ensuring that bugs are thoroughly tested and fixed without introducing additional issues. By following the red, green, refactor process, developers <code>class Progress: NSObject</code> can ensure that their <code>code</code> is clean, stable, and reliable. So next time you encounter a bug, consider using <em>test-driven</em> bug fixing to ensure a more efficient and effective fix, even if you are working with legacy code.</p><img src="https://your-website-url.com/images/test_screenshot.png" alt="test"/><img src="https://your-website-url.com/images/test_screenshot_small.png" alt="test"/><img src="https://your-website-url.com/images/test_screenshot_small2.png" alt="test"/><p>Test-driven bug fixing is a <strong>powerful</strong> technique for ensuring that bugs are thoroughly tested and fixed without introducing additional issues. By following the red, green, refactor process, developers <code>class Progress: NSObject</code> can ensure that their <code>code</code> is clean, stable, and reliable. So next time you encounter a bug, consider using <em>test-driven</em> bug fixing to ensure a more efficient and effective fix, even if you are working with legacy code.</p><pre><code><span class="keyword">class</span> MyCustomThemeTests: <span class="type">XCTestCase</span> {
    
    <span class="keyword">func</span> testMyCustomComponent() <span class="keyword">throws</span> {
        <span class="keyword">let</span> component = <span class="type">MyCustomComponent</span>(title: <span class="string">"Test Title"</span>, description: <span class="string">"Test Description"</span>)
        <span class="keyword">let</span> html = component.<span class="call">render</span>()
        
        <span class="comment">// Assert that the generated HTML contains the expected content</span>
        <span class="call">XCTAssertTrue</span>(html.<span class="call">contains</span>(<span class="string">"Test Title"</span>))
        <span class="call">XCTAssertTrue</span>(html.<span class="call">contains</span>(<span class="string">"Test Description"</span>))
    }
    
    <span class="comment">// Add more test cases for other components as needed...</span>
}
</code></pre><ol><li>Test-driven bug fixing is a powerful technique for ensuring that bugs are thoroughly tested and fixed without introducing additional issues. By following the red, green, refactor process, developers can ensure that their code is clean, stable, and reliable. So next time you encounter a bug, consider using test-driven bug fixing to ensure a more efficient and effective fix, even if you are working with legacy code.</li><li>Test-driven bug fixing is a powerful technique for ensuring that bugs are thoroughly tested and fixed without introducing additional issues. By following the red, green, refactor process, developers can ensure that their code is clean, stable, and reliable. So next time you encounter a bug, consider using test-driven bug fixing to ensure a more efficient and effective fix, even if you are working with legacy code.</li></ol><ul><li>Test-driven bug fixing is a powerful technique for ensuring that bugs are thoroughly tested and fixed without introducing additional issues. By following the red, green, refactor process, developers can ensure that their code is clean, stable, and reliable. So next time you encounter a bug, consider using test-driven bug fixing to ensure a more efficient and effective fix, even if you are working with legacy code.</li><li>Test-driven bug fixing is a powerful technique for ensuring that bugs are thoroughly tested and fixed without introducing additional issues. By following the red, green, refactor process, developers can ensure that their code is clean, stable, and reliable. So next time you encounter a bug, consider using test-driven bug fixing to ensure a more efficient and effective fix, even if you are working with legacy code.</li></ul>]]></content:encoded></item></channel></rss>