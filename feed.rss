<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Henrik Forsberg</title><description>Join me, Henrik Forsberg, on a humble journey through the realm of Swift and iOS development. Explore my blog, where I share insights, tutorials, and thoughts on the ever-evolving world of coding. Let's learn and grow together as we navigate the exciting landscape of iOS development.</description><link>https://forsberg.dev</link><language>en</language><lastBuildDate>Wed, 13 Dec 2023 09:57:18 +0100</lastBuildDate><pubDate>Wed, 13 Dec 2023 09:57:18 +0100</pubDate><ttl>250</ttl><atom:link href="https://forsberg.dev/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://forsberg.dev/posts/MARK-comments</guid><title>Enhancing Readability: The Power of MARK Comments in Swift Development</title><description>When attempting to maintain our codebase it’s a good idea to have a clear and consistent way of structuring our code so it remains readable and easy to navigate. This becomes increasingly important as our codebase grows larger in size. There are several approaches and tools available for achieving this but the use of MARK comments is the one I want to highlight with this post.</description><link>https://forsberg.dev/posts/MARK-comments</link><pubDate>Tue, 12 Dec 2023 01:00:00 +0100</pubDate><content:encoded><![CDATA[<h1>Enhancing Readability: The Power of MARK Comments in Swift Development</h1><p>When attempting to maintain our codebase it’s a good idea to have a clear and consistent way of structuring our code so it remains readable and easy to navigate. This becomes increasingly important as our codebase grows larger in size. There are several approaches and tools available for achieving this but the use of MARK comments is the one I want to highlight with this post.</p><h2>What is a MARK comment and how do we use them?</h2><p>MARK comments - also known as "MARK lines" - are comments with special powers that are interpreted by Xcode a little differently compared to regular comments. They serve as a kind of labels within our code to help us organize it and keep it easy to navigate and readable in both our code and Xcode's jump bar and minimap. There are three different types we can use to annotate our code; <code>MARK</code>, <code>TODO</code> and <code>FIXME</code>. Let's take a closer look at each one.</p><h3>MARK</h3><p>The <code>MARK</code> type is probably the most commonly used type of MARK comments (hence the name). With it, we can add a label, a dividing line or both to annotate sections of our files and make them more organized.</p><h4>MARK with only label</h4><pre><code><span class="comment">// MARK: Properties</span>
 
<span class="keyword">let</span> myConstant1: <span class="type">String</span>
<span class="keyword">var</span> myVariable1: <span class="type">String</span>
</code></pre><p>This adds an icon and the label "Properties" to the jump bar: <img src="https://forsberg.dev/images/mark-label.png" alt="MARK comment with only label"/></p><h4>MARK with only divider</h4><p>Sometimes we may just want to compartmentalize our code to simply make it clear that a chunk of code is separate, without adding labels. For this we can add a divider with the same <code>// MARK:</code> followed by a dash:</p><pre><code><span class="keyword">private func</span> methodBelongingToFirstChunk() {}

<span class="comment">// MARK: -</span>

<span class="keyword">private func</span> methodBelongingToAnotherChunk() {}
</code></pre><p>As expected, this shows a dividing line in the jump bar: <img src="https://forsberg.dev/images/mark-divider.png" alt="MARK comment with only label"/></p><h4>MARK with both divider and label</h4><p>As mentioned we can easily add both a divider and a label.</p><pre><code><span class="comment">// MARK: - Private Methods</span>
    
<span class="keyword">private func</span> myPrivateMethod() {}

<span class="keyword">private func</span> myOtherPrivateMethod() {}
</code></pre><p>In the jump bar, this places a divider before the label: <img src="https://forsberg.dev/images/mark-divider-and-label.png" alt="MARK comment with only label"/></p><p>The placement of the dash determines where the divider ends up so if we prefer the divider to be placed below the label we can simply put the dash at the end of the comment:</p><pre><code><span class="comment">// MARK: Private Methods -</span>
    
<span class="keyword">private func</span> myPrivateMethod() {}

<span class="keyword">private func</span> myOtherPrivateMethod() {}
</code></pre><img src="https://forsberg.dev/images/mark-divider-and-label-after.png" alt="MARK comment with only label"/><p>When looking at the minimap, MARK comments provide a clear overview of the file: <img src="https://forsberg.dev/images/mark-minimap.png" alt="MARK comment with only label"/></p><p>Compared to not using MARK comments: <img src="https://forsberg.dev/images/mark-no-mark.png" alt="MARK comment with only label"/></p><h3>TODO and FIXME</h3><p>The <code>TODO</code> and <code>FIXME</code> types work exactly the same (even with dashes) but display their own respective icons to the jump bar. Keep in mind, however, that these comments do not show on the minimap.</p><pre><code><span class="keyword">public func</span> myMethod() {
    <span class="comment">// TODO: Add implementation here</span>
}
</code></pre><img src="https://forsberg.dev/images/mark-todo.png" alt="MARK comment with only label"/><pre><code><span class="keyword">public func</span> myOtherMethod() {
    <span class="comment">// FIXME: Make this make sense</span>        
}
</code></pre><img src="https://forsberg.dev/images/mark-fixme.png" alt="MARK comment with only label"/><h2>Conclusion</h2><p>Structuring our code is always a good idea, especially when the files grow large. Keep in mind, though, that large files could be indicators that we need to refactor our code to split up the responsibilities into smaller ones and keep it more modular and more easily maintained. We should also not go overboard and start putting MARK comments on every other line, that would just clutter our files and defeat their purpose. Ultimately - as with so many things - it’s up to you and your team to find the right balance of how to use them.</p><p>Personally I try to avoid merging code containing <code>FIXME</code> or <code>TODO</code> comments, as my experience is that they tend to be easily forgotten. If you find yourself in a situation where you <em>really</em> need to merge your unfinished code (we all know it happens sometimes) with these types of comments, I highly recommend using a <code>#warning("")</code> statement instead.</p><pre><code><span class="keyword">public func</span> myMethod() {
    <span class="preprocessing">#warning</span>(<span class="string">"TODO: Add implementation here"</span>)
}
</code></pre><p>This makes the compiler help remind you about their existence by putting a warning about it in the Issues navigator.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://forsberg.dev/posts/Dependency%20Inversion%20Principle</guid><title>Dependency Inversion Principle in Swift</title><description>High level modules should not depend upon low level modules. Both should depend upon abstractions.  Abstractions should not depend upon details. Details should depend upon abstractions. High level modules should not depend upon low level modules. Both should depend upon abstractions.  Abstractions should not depend upon details. Details should depend upon abstractions. High level modules should not depend upon low level modules. Both should depend upon abstractions.  Abstractions should not depend upon details. Details should depend upon abstractions. High level modules should not depend upon low level modules. Both should depend upon abstractions.  Abstractions should not depend upon details. Details should depend upon abstractions. High level modules should not depend upon low level modules. Both should depend upon abstractions.  Abstractions should not depend upon details. Details should depend upon abstractions.</description><link>https://forsberg.dev/posts/Dependency%20Inversion%20Principle</link><pubDate>Fri, 1 Dec 2023 01:00:00 +0100</pubDate><content:encoded><![CDATA[<h1>Dependency Inversion Principle in Swift</h1><p>test</p>]]></content:encoded></item><item><guid isPermaLink="true">https://forsberg.dev/posts/Interface%20Segregation%20Principle</guid><title>Interface Segregation Principle in Swift</title><description>Clients should not be forced to depend upon interfaces that they do not use. Clients should not be forced to depend upon interfaces that they do not use. Clients should not be forced to depend upon interfaces that they do not use. Clients should not be forced to depend upon interfaces that they do not use. Clients should not be forced to depend upon interfaces that they do not use.</description><link>https://forsberg.dev/posts/Interface%20Segregation%20Principle</link><pubDate>Wed, 1 Nov 2023 01:00:00 +0100</pubDate><content:encoded><![CDATA[<h1>Interface Segregation Principle in Swift</h1>]]></content:encoded></item><item><guid isPermaLink="true">https://forsberg.dev/posts/Liskov%20Substitution%20Principle</guid><title>Liskov Substitution Principle in Swift</title><description>Programs that references an object from a base class must be able to use an object of a derived class without behavior differences and without knowing about its existence. Programs that references an object from a base class must be able to use an object of a derived class without behavior differences and without knowing about its existence. Programs that references an object from a base class must be able to use an object of a derived class without behavior differences and without knowing about its existence. Programs that references an object from a base class must be able to use an object of a derived class without behavior differences and without knowing about its existence. Programs that references an object from a base class must be able to use an object of a derived class without behavior differences and without knowing about its existence.</description><link>https://forsberg.dev/posts/Liskov%20Substitution%20Principle</link><pubDate>Sun, 1 Oct 2023 01:00:00 +0200</pubDate><content:encoded><![CDATA[<h1>Liskov Substitution Principle in Swift</h1>]]></content:encoded></item><item><guid isPermaLink="true">https://forsberg.dev/posts/Open-Closed%20Principle%20in%20Swift</guid><title>Open-Closed Principle in Swift</title><description>Software Entities (classes, modules, functions, etc) should be open for extension, but closed for modification. Software Entities (classes, modules, functions, etc) should be open for extension, but closed for modification. Software Entities (classes, modules, functions, etc) should be open for extension, but closed for modification. Software Entities (classes, modules, functions, etc) should be open for extension, but closed for modification. Software Entities (classes, modules, functions, etc) should be open for extension, but closed for modification.</description><link>https://forsberg.dev/posts/Open-Closed%20Principle%20in%20Swift</link><pubDate>Fri, 1 Sep 2023 01:00:00 +0200</pubDate><content:encoded><![CDATA[<h1>Open-Closed Principle in Swift</h1><p>Software Entities (classes, modules, functions, etc) should be open for extension, but closed for modification. Software Entities (classes, modules, functions, etc) should be open for extension, but closed for modification. Software Entities (classes, modules, functions, etc) should be open for extension, but closed for modification. Software Entities (classes, modules, functions, etc) should be open for extension, but closed for modification. Software Entities (classes, modules, functions, etc) should be open for extension, but closed for modification.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://forsberg.dev/posts/Single%20Responsibility%20Principle%20in%20Swift</guid><title>SOLID Principles: Single Responsibility Principle in Swift</title><description>As a project's codebase matures and becomes more complex, it's very easy to lose control over maintainability and scalability of the app. It becomes increasingly important to follow best practices and use well-established design patterns and architectures to ensure a robust application. The SOLID principles are a very common set of principles we can use for this purpose. In this post, we take a look at the "S" in SOLID used for avoiding too many responsibilities within a class or function; the Single Responsibility Principle.</description><link>https://forsberg.dev/posts/Single%20Responsibility%20Principle%20in%20Swift</link><pubDate>Fri, 18 Aug 2023 01:00:00 +0200</pubDate><content:encoded><![CDATA[<h1>SOLID Principles: Single Responsibility Principle in Swift</h1><p>As a project's codebase matures and becomes more complex, it's very easy to lose control over maintainability and scalability of the app. It becomes increasingly important to follow best practices and use well-established design patterns and architectures to ensure a robust application. The SOLID principles are a very common set of principles we can use for this purpose. In this post, we take a look at the "S" in SOLID used for avoiding too many responsibilities within a class or function; the Single Responsibility Principle.</p><h2>What is the Single Responsibility Principle?</h2><p>First of all, we need to understand what the SRP is and why we need it. What problem does it solve?</p><p>Robert C. Martin (the famous Uncle Bob) defines the principle like this:</p><blockquote><p>"A class should have one, and only one, reason to change."</p></blockquote><p>Basically the idea is that every module, class or function should only have one responsibility or job within an application. This makes it easier to understand, modify, maintain and reuse.</p><p>Sounds good. But what does it actually mean? And how do we spot it in code?</p><h2>Identifying the Problem: Multiple Responsibilities in One</h2><p>I find it easier to understand an issue by looking at an example, so let's see some code. Imagine a scenario where we have a class or function that juggles multiple responsibilities. Let's say we have a <code>Spaceship</code> class:</p><pre><code><span class="keyword">class</span> Spaceship {
    <span class="keyword">func</span> travel(destination: <span class="type">String</span>) {
        <span class="comment">// Travel to the specified destination</span>
    }
    
    <span class="keyword">func</span> formLandingParty() {
        <span class="comment">// Form a landing party using the spaceship's crew</span>
    }
}
</code></pre><p>In this simple example we see that the <code>Spaceship</code> class handles logic for both travel and forming landing parties. It has multiple responsibilities and thus it is violating the Single Responsibility Principle. Even though at first glance this might seem fine and quite convenient, as changes pile up over time (as we all know they do) the class could easily become a tangled mess. Adding a new feature might unintentionally break existing functionality and debugging becomes a daunting task. So how do we prevent this from happening?</p><h2>Applying the Solution: SRP</h2><p>The Single Responsibility Principle comes to the rescue by advocating for a clear separation of concerns. Instead of having a single class do everything, we break down the responsibilities into distinct, standalone entities. Taking the previous example, we create separate classes for dealing with traveling and managing crew members. Consider the following:</p><pre><code><span class="keyword">class</span> Spaceship {
    <span class="keyword">func</span> travel(destination: <span class="type">String</span>) {
        <span class="comment">// Travel to the specified destination</span>
    }
}

<span class="keyword">class</span> CrewManager {
    <span class="keyword">func</span> formLandingParty(spaceship: <span class="type">Spaceship</span>) {
        <span class="comment">// Form a landing party using the spaceship's crew</span>
    }
}
</code></pre><p>By applying SRP, each class now has a single focus, making code easier to understand, maintain, and extend. Changes related to travel won't affect crew management, and vice versa. This separation results in a more modular codebase, reducing the chances of introducing unintended side effects. Also, it will be easier to test these classes in isolation.</p><p>The benefits extend beyond initial development—maintenance and debugging become smoother processes, and the overall quality of the codebase improves.</p><p>In conclusion, the Single Responsibility Principle is a powerful tool that promotes cleaner, more maintainable code. By adhering to SRP, developers can address the challenges of growing codebases head-on, fostering a more efficient and enjoyable development experience.</p><p>Identifying SRP violations</p><h2>How to find these violations?</h2><p>Enforcing SRP</p><p>Mention: Coupling Tight coupling = Changing one class results in having to change a lot of other classes to get the program working again Cohesion Low Cohesion = The class contains fields and methods/functions that are unrelated to each other in any meaningful way. A good way to spot this is if methods in a class don't reuse the same fields. Each method is using different fields from the class.</p><p>So a class adhering to SRP should preferrably have loose coupling and high cohesion.</p><p>Swiss army knife is a great example of SRP violation. Trying to do too much and end up doing nothing well.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://forsberg.dev/posts/Test-Driven%20Bug%20Fixing</guid><title>Test-Driven Bug Fixing</title><description>Boost your confidence and ensure solid fixes by applying the Red, Green, Refactor process.</description><link>https://forsberg.dev/posts/Test-Driven%20Bug%20Fixing</link><pubDate>Sun, 19 Mar 2023 13:29:00 +0100</pubDate><content:encoded><![CDATA[<h1>Test-Driven Bug Fixing</h1><h2>Introduction</h2><p>As a software developer, it's not uncommon to encounter bugs in code. Fixing bugs can be a tedious and time-consuming process, but there are ways to make it more efficient. One such way is through test-driven bug fixing, which involves using the red, green, refactor process.</p><h2>The Red, Green, Refactor Process</h2><p>The red, green, refactor process is a way of writing code that ensures it is thoroughly tested before it is committed to the codebase. It involves three steps:</p><h3>Red 🔴</h3><p>The first step is to write a failing test. This is the "red" step because the test should fail at this stage. The test should be specific to the bug that needs to be fixed and should only test for that particular behavior.</p><h3>Green 🟢</h3><p>The second step is to write the minimum amount of code to make the test pass. This is the "green" step because the test should now pass. The code written at this stage should only address the specific bug being fixed and should not add any additional functionality.</p><h3>Refactor 🔄</h3><p>The final step is to refactor the code to make it easier to read, maintain, and extend. This is the "refactor" step because the code is being cleaned up and improved without changing its behavior. Refactoring at this stage ensures that the codebase remains clean and easy to work with.</p><h4>Header 4</h4><p>The final step is to refactor the code to make it easier to read, maintain, and extend. This is the "refactor" step because the code is being cleaned up and improved without changing its behavior. Refactoring at this stage ensures that the codebase remains clean and easy to work with.</p><h2>Benefits of Test Driven Bug Fixing</h2><p>Test-driven bug fixing has several benefits. First, it ensures that the bug is fixed thoroughly and does not introduce any additional issues into the codebase. Second, it makes the codebase more stable and reliable by ensuring that all changes are properly tested. Finally, it can save time in the long run by catching issues early in the development process.</p><h2>Using Test Driven Bug Fixing with Legacy Code</h2><p>While implementing test-driven bug fixing may be more challenging with legacy code, it can still be done. By writing tests that cover the most critical parts of the code, developers can gradually build up test coverage over time. As more tests are written, the codebase becomes more reliable and easier to work with. It's important to note that the red, green, refactor process may need to be adapted to fit the specific needs of the legacy codebase.</p><h2>Conclusion</h2><p>Test-driven bug fixing is a powerful technique for ensuring that bugs are thoroughly tested and fixed without introducing additional issues. By following the red, green, refactor process, developers can ensure that their code is clean, stable, and reliable. So next time you encounter a bug, consider using test-driven bug fixing to ensure a more efficient and effective fix, even if you are working with legacy code.</p><ol><li>Test-driven bug fixing is a powerful technique for ensuring that bugs are thoroughly tested and fixed without introducing additional issues. By following the red, green, refactor process, developers can ensure that their code is clean, stable, and reliable. So next time you encounter a bug, consider using test-driven bug fixing to ensure a more efficient and effective fix, even if you are working with legacy code.<ul><li>bla bla bla</li><li>hya hya hya hya</li><li>ho ho ho</li></ul></li></ol><ol start="2"><li>Test-driven bug fixing is a powerful technique for ensuring that bugs are thoroughly tested and fixed without introducing additional issues. By following the red, green, refactor process, developers can ensure that their code is clean, stable, and reliable. So next time you encounter a bug, consider using test-driven bug fixing to ensure a more efficient and effective fix, even if you are working with legacy code.</li></ol><p>Test-driven bug fixing is a powerful technique for ensuring that bugs are thoroughly tested and fixed without introducing additional issues. By following the red, green, refactor process, developers <a href="https://www.google.se">developers</a> developers can ensure that their code is clean, stable, and reliable. So next time you encounter a bug, consider using test-driven bug fixing to ensure a more efficient and effective fix, even if you are working with legacy code.</p><blockquote><p>Test-driven bug fixing is a powerful technique for ensuring that bugs are thoroughly tested and fixed without introducing additional issues. By following the red, green, refactor process, developers can ensure that their code is clean, stable, and reliable. So next time you encounter a bug, consider using test-driven bug fixing to ensure a more efficient and effective fix, even if you are working with legacy code.</p></blockquote><p>Test-driven bug fixing is a <strong>powerful</strong> technique for ensuring that bugs are thoroughly tested and fixed without introducing additional issues. By following the red, green, refactor process, developers <code>class Progress: NSObject</code> can ensure that their <code>code</code> is clean, stable, and reliable. So next time you encounter a bug, consider using <em>test-driven</em> bug fixing to ensure a more efficient and effective fix, even if you are working with legacy code.</p><hr><p>Test-driven bug fixing is a <strong>powerful</strong> technique for ensuring that bugs are thoroughly tested and fixed without introducing additional issues. By following the red, green, refactor process, developers <code>class Progress: NSObject</code> can ensure that their <code>code</code> is clean, stable, and reliable. So next time you encounter a bug, consider using <em>test-driven</em> bug fixing to ensure a more efficient and effective fix, even if you are working with legacy code.</p><img src="https://forsberg.dev/images/test_screenshot.png" alt="test"/><img src="https://forsberg.dev/images/test_screenshot_small.png" alt="test"/><img src="https://forsberg.dev/images/test_screenshot_small2.png" alt="test"/><p>Test-driven bug fixing is a <strong>powerful</strong> technique for ensuring that bugs are thoroughly tested and fixed without introducing additional issues. By following the red, green, refactor process, developers <code>class Progress: NSObject</code> can ensure that their <code>code</code> is clean, stable, and reliable. So next time you encounter a bug, consider using <em>test-driven</em> bug fixing to ensure a more efficient and effective fix, even if you are working with legacy code.</p><pre><code><span class="keyword">class</span> MyCustomThemeTests: <span class="type">XCTestCase</span> {
    
    <span class="keyword">func</span> testMyCustomComponent() <span class="keyword">throws</span> {
        <span class="keyword">let</span> component = <span class="type">MyCustomComponent</span>(title: <span class="string">"Test Title"</span>, description: <span class="string">"Test Description"</span>)
        <span class="keyword">let</span> html = component.<span class="call">render</span>()
        
        <span class="comment">// Assert that the generated HTML contains the expected content</span>
        <span class="call">XCTAssertTrue</span>(html.<span class="call">contains</span>(<span class="string">"Test Title"</span>))
        <span class="call">XCTAssertTrue</span>(html.<span class="call">contains</span>(<span class="string">"Test Description"</span>))
    }
    
    <span class="comment">// Add more test cases for other components as needed...</span>
}
</code></pre><ol><li>Test-driven bug fixing is a powerful technique for ensuring that bugs are thoroughly tested and fixed without introducing additional issues. By following the red, green, refactor process, developers can ensure that their code is clean, stable, and reliable. So next time you encounter a bug, consider using test-driven bug fixing to ensure a more efficient and effective fix, even if you are working with legacy code.</li><li>Test-driven bug fixing is a powerful technique for ensuring that bugs are thoroughly tested and fixed without introducing additional issues. By following the red, green, refactor process, developers can ensure that their code is clean, stable, and reliable. So next time you encounter a bug, consider using test-driven bug fixing to ensure a more efficient and effective fix, even if you are working with legacy code.</li></ol><ul><li>Test-driven bug fixing is a powerful technique for ensuring that bugs are thoroughly tested and fixed without introducing additional issues. By following the red, green, refactor process, developers can ensure that their code is clean, stable, and reliable. So next time you encounter a bug, consider using test-driven bug fixing to ensure a more efficient and effective fix, even if you are working with legacy code.</li><li>Test-driven bug fixing is a powerful technique for ensuring that bugs are thoroughly tested and fixed without introducing additional issues. By following the red, green, refactor process, developers can ensure that their code is clean, stable, and reliable. So next time you encounter a bug, consider using test-driven bug fixing to ensure a more efficient and effective fix, even if you are working with legacy code.</li></ul>]]></content:encoded></item></channel></rss>