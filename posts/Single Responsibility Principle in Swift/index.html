<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Henrik Forsberg"/><link rel="canonical" href="https://forsberg.dev/posts/Single%20Responsibility%20Principle%20in%20Swift"/><meta name="twitter:url" content="https://forsberg.dev/posts/Single%20Responsibility%20Principle%20in%20Swift"/><meta name="og:url" content="https://forsberg.dev/posts/Single%20Responsibility%20Principle%20in%20Swift"/><title>SOLID Principles: Single Responsibility Principle in Swift | Henrik Forsberg</title><meta name="twitter:title" content="SOLID Principles: Single Responsibility Principle in Swift | Henrik Forsberg"/><meta name="og:title" content="SOLID Principles: Single Responsibility Principle in Swift | Henrik Forsberg"/><meta name="description" content="As a project's codebase matures and becomes more complex, it's very easy to lose control over maintainability and scalability of the app. It becomes increasingly important to follow best practices and use well-established design patterns and architectures to ensure a robust application. The SOLID principles are a very common set of principles we can use for this purpose. In this post, we take a look at the "S" in SOLID used for avoiding too many responsibilities within a class or function; the Single Responsibility Principle."/><meta name="twitter:description" content="As a project's codebase matures and becomes more complex, it's very easy to lose control over maintainability and scalability of the app. It becomes increasingly important to follow best practices and use well-established design patterns and architectures to ensure a robust application. The SOLID principles are a very common set of principles we can use for this purpose. In this post, we take a look at the "S" in SOLID used for avoiding too many responsibilities within a class or function; the Single Responsibility Principle."/><meta name="og:description" content="As a project's codebase matures and becomes more complex, it's very easy to lose control over maintainability and scalability of the app. It becomes increasingly important to follow best practices and use well-established design patterns and architectures to ensure a robust application. The SOLID principles are a very common set of principles we can use for this purpose. In this post, we take a look at the "S" in SOLID used for avoiding too many responsibilities within a class or function; the Single Responsibility Principle."/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Henrik Forsberg"/></head><head><script src="https://kit.fontawesome.com/88005863b2.js" crossorigin="anonymous"></script></head><body class="item-page"><header><div class="wrapper"><a href="/"><img src="/images/logo_white_initials.png" class="header-logo"/></a><nav><ul><li><a href="/posts" class="selected">Posts</a></li><li><a href="/about">About</a></li></ul></nav></div></header><div class="wrapper"><article class="single-post"><div class="content"><h1>SOLID Principles: Single Responsibility Principle in Swift</h1><p>As a project's codebase matures and becomes more complex, it's very easy to lose control over maintainability and scalability of the app. It becomes increasingly important to follow best practices and use well-established design patterns and architectures to ensure a robust application. The SOLID principles are a very common set of principles we can use for this purpose. In this post, we take a look at the "S" in SOLID used for avoiding too many responsibilities within a class or function; the Single Responsibility Principle.</p><h2>What is the Single Responsibility Principle?</h2><p>First of all, we need to understand what the SRP is and why we need it. What problem does it solve?</p><p>Robert C. Martin (the famous Uncle Bob) defines the principle like this:</p><blockquote><p>"A class should have one, and only one, reason to change."</p></blockquote><p>Basically the idea is that every module, class or function should only have one responsibility or job within an application. This makes it easier to understand, modify, maintain and reuse.</p><p>Sounds good. But what does it actually mean? And how do we spot it in code?</p><h2>Identifying the Problem: Multiple Responsibilities in One</h2><p>I find it easier to understand an issue by looking at an example, so let's see some code. Imagine a scenario where we have a class or function that juggles multiple responsibilities. Let's say we have a <code>Spaceship</code> class:</p><pre><code><span class="keyword">class</span> Spaceship {
    <span class="keyword">func</span> travel(destination: <span class="type">String</span>) {
        <span class="comment">// Travel to the specified destination</span>
    }
    
    <span class="keyword">func</span> formLandingParty() {
        <span class="comment">// Form a landing party using the spaceship's crew</span>
    }
}
</code></pre><p>In this simple example we see that the <code>Spaceship</code> class handles logic for both travel and forming landing parties. It has multiple responsibilities and thus it is violating the Single Responsibility Principle. Even though at first glance this might seem fine and quite convenient, as changes pile up over time (as we all know they do) the class could easily become a tangled mess. Adding a new feature might unintentionally break existing functionality and debugging becomes a daunting task. So how do we prevent this from happening?</p><h2>Applying the Solution: SRP</h2><p>The Single Responsibility Principle comes to the rescue by advocating for a clear separation of concerns. Instead of having a single class do everything, we break down the responsibilities into distinct, standalone entities. Taking the previous example, we create separate classes for dealing with traveling and managing crew members. Consider the following:</p><pre><code><span class="keyword">class</span> Spaceship {
    <span class="keyword">func</span> travel(destination: <span class="type">String</span>) {
        <span class="comment">// Travel to the specified destination</span>
    }
}

<span class="keyword">class</span> CrewManager {
    <span class="keyword">func</span> formLandingParty(spaceship: <span class="type">Spaceship</span>) {
        <span class="comment">// Form a landing party using the spaceship's crew</span>
    }
}
</code></pre><p>By applying SRP, each class now has a single focus, making code easier to understand, maintain, and extend. Changes related to travel won't affect crew management, and vice versa. This separation results in a more modular codebase, reducing the chances of introducing unintended side effects. Also, it will be easier to test these classes in isolation.</p><p>The benefits extend beyond initial development—maintenance and debugging become smoother processes, and the overall quality of the codebase improves.</p><p>In conclusion, the Single Responsibility Principle is a powerful tool that promotes cleaner, more maintainable code. By adhering to SRP, developers can address the challenges of growing codebases head-on, fostering a more efficient and enjoyable development experience.</p><p>Identifying SRP violations</p><h2>How to find these violations?</h2><p>Enforcing SRP</p><p>Mention: Coupling Tight coupling = Changing one class results in having to change a lot of other classes to get the program working again Cohesion Low Cohesion = The class contains fields and methods/functions that are unrelated to each other in any meaningful way. A good way to spot this is if methods in a class don't reuse the same fields. Each method is using different fields from the class.</p><p>So a class adhering to SRP should preferrably have loose coupling and high cohesion.</p><p>Swiss army knife is a great example of SRP violation. Trying to do too much and end up doing nothing well.</p></div><ul class="tag-list"><li><a href="/tags/software-architecture">Software Architecture</a></li><li><a href="/tags/solid-principles">SOLID Principles</a></li></ul></article></div><footer><p class="contact-icons"><a href="https://twitter.com/forsberg_dev" target="_blank"><span class="fab fa-square-x-twitter"></span></a><a href="https://github.com/readyruncode" target="_blank"><span class="fab fa-github-square"></span></a><a href="https://www.linkedin.com/in/henrik-forsberg" target="_blank"><span class="fab fa-linkedin"></span></a><a href="https://www.instagram.com/forsberg.dev" target="_blank"><span class="fab fa-instagram-square"></span></a><a href="mailto:henrik@forsberg.dev" target="_blank"><span class="fas fa-envelope-square"></span></a></p><p>Copyright © 2014-2024 <a>Henrik Forsberg</a>, All Rights Reserved</p><p class="feed-paragraph"><a href="https://forsberg.dev">forsberg.dev</a><a href="/feed.rss">RSS feed</a></p></footer></body></html>